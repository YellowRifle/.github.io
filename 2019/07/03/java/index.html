<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Java IO相关操作(socket) | YellowRifle Thinking</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="YellowRifle"><meta name="designer" content="minfive"><meta name="keywords" content="java,golang,日常分享,阿美咔叽,篮球"><meta name="description" content="undefined"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://yellowrifle.github.io/2019/07/03/java/index.html"><link rel="icon" type="image/png" href="/images/websource/avator.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="YellowRifle" type="application/atom+xml"><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 5.1.1"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/images/websource/giphy.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="YellowRifle" alt="YellowRifle"><img src="/images/websource/icon.png" alt="YellowRifle"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/images/socket/aaio.png" alt="Java IO相关操作(socket)"></div><header class="post__info"><h1 class="post__title">Java IO相关操作(socket)</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">YellowRifle</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2019-07-03</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/NIO/">NIO</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>java中最频繁的IO操作就是对网络的的IO了，其本质也是对文件进行IO操作，java中网络通信基石就是socket,windows和unix中网络通讯首选socket,当然也有其他方式的,待探讨.</p><p><strong>关于socket</strong>:</p><p>我的理解既然socket是tcp协议实现的一种接口，工作在传输层，其后的应用层http,ftp,dns等也是基于tcp，本质上也是通过socket进行实现(各自是一种特殊的socket),再高级一点的协议和websocket,netty,emqtt,activemq等都需要用到socket(待补充)<br>Socket本质上还是文件，因为Linux上一切皆文件，就是io操作，这里先看一下unix下的5种网络io模型，对比java中的实现理解要清晰点.</p><p><font color="red">“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答(转)</font></p><p><strong>关于阻塞与非阻塞</strong></p><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p><strong>关于同步与异步:</strong></p><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p><p>而异步则是相反，<em>调用</em>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>典型的异步编程模型比如Node.js</p><p><strong>阻塞与非阻塞与是否同步异步无关</strong></p><p><strong>Unix的5种Io模型:</strong></p><ul><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO(SIGIO)</li><li>异步IO</li></ul><p><strong>一、同步阻塞IO（Blocking IO）:</strong></p><p>用户调用Io操作后,进入block状态,直到数据读取数据完成，才释放cpu，大多数操作都是同步阻塞的,看下图<br><img src="/images/socket/aaio.png"></p><p>《linux高级程序设计》中讲到</p><blockquote><p>一旦进程期望读取数据,就调用read/write函数，进程从调用这些函数开始，一直到返回这段时间都处在阻塞状态，当recv正常返回时，进程继续其他操作</p></blockquote><p><strong>二、同步非阻塞IO（Non-blocking IO）:</strong></p><p>非阻塞IO就是用户进程调用IO系统调用，如果被读取的数据没有准备好，则立即返回，与<strong>阻塞式io</strong>区别就是，当数据没准备好时，阻塞式就会阻塞当前进程直到数据读写完毕，非阻塞则是数据没准备好，那好我先返回，返回个错误值。<br><img src="/images/socket/notaaio.png"></p><p>这种方式最大的问题应该就是它需要反复地去轮询数据是否准备好，这将是一个极浪费 CPU资源的操作，但是在大量短连接请求的http服务器中，由于并发请求数很高，所以几乎每一次recvfrom调用都有数据拷贝，所以也不会十分浪费CPU资源。</p><p><strong>三、IO多路复用（IO Multiplexing）:</strong></p><p>IO多路即经典的Reactor设计模式，有时也称为异步阻塞IO，unix下由select()系统调用或poll()或epoll()来实现（下面会说道它们的区别），本质上是将访问数据是否就绪的函数与读取数据的函数分开。</p><p>《linux高级程序设计》中</p><blockquote><p>多路复用方式任然是以阻塞方式等待文件Io准备好，但其可以同时等待多个文件描述符，如果当前有一个或多个socket有状态变化,则从阻塞状态返回，转而处理该文件描述符Io操作</p></blockquote><p><img src="/images/socket/mutiio.png"></p><p>多路复用的高级之处在于:它能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p><p>IO 多路技术一般在下面这些情况中被使用：</p><p>1、当一个客户端需要同时处理多个文件描述符的输入输出操作的时候（一般来说是标准的输入输出和网络套接字)，I/O 多路复用技术将会有机会得到使用。</p><p>2、当程序需要同时进行多个套接字的操作的时候。</p><p>3、如果一个 TCP 服务器程序同时处理正在侦听网络连接的套接字和已经连接好的套接字。</p><p>4、如果一个服务器程序同时使用 TCP 和 UDP 协议。</p><p>5、如果一个服务器同时使用多种服务并且每种服务可能使用不同的协议（比如 inetd就是这样的）。</p><p><strong>四、信号驱动IO(SIGIO):</strong></p><p>内核提供一种异步数据处理方式，让内核在文件描述符就绪后产生SIGIO信号，通知用户数据或空间准备好，信号驱动式IO模型不需要轮询检查底层IO数据是否就绪，而是被动接收信号，然后再调用recvfrom执行IO操作。</p><p><strong>比起多路复用IO模型来说，信号驱动IO模型针对的是一个IO的完成过程， 而多路复用IO模型针对的是多个IO同时进行时候的场景</strong></p><p><img src="/images/socket/singnalio.png"></p><p><strong>五、异步IO:</strong></p><p>异步IO模型的工作机制是，将整个IO操作（包括等待数据就绪，复制数据到应用程序工作空间）全都交给操作系统完成，操作系统完成整个过程之后，再通知应用程序。</p><p>异步IO模型跟信号驱动IO模型很相似，但是区别是信号驱动模型是在数据就绪的时候通知应用程序，应用程序再调用系统函数recvfrom进行IO操作。</p><p>而异步IO模型则是数据就绪且操作系统已经将数据拷贝进应用程序运行空间之后，操作系统再通知应用程序，这个过程中应用程序不需要阻塞。异步IO可以如下图表示</p><p><img src="/images/socket/synchronizedio.png"></p><h2 id="Java中的BIO-NIO-AIO"><a href="#Java中的BIO-NIO-AIO" class="headerlink" title="Java中的BIO,NIO,AIO:"></a>Java中的BIO,NIO,AIO:</h2><p><strong>netty中比较从权威的说法</strong></p><p><img src="/images/socket/totolinfo.png"></p><p>BIO:b有两说，一为base，jdk中最早抽象出的io体系；一为block，jdk 1.0 中的io体系是阻塞的。所以两说皆有道理，一般我们认为b取block之意 。</p><p>NIO:n也有两说，一为new，针对base而言；一为non-block，针对block而言 jdk1.4后推出,传统io是面向字节流的，而nio是面向缓冲区的。</p><p>AIO:异步IO也有NI0.2之说。</p><p><strong>BIO(同步阻塞)通信模型图:</strong><br><img src="/images/socket/biomodel.png"><br>每建立一个Socket连接时，同时创建一个新线程对该Socket进行单独通信（采用阻塞的方式通信）。这种方式具有很高的响应速度，并且控制起来也很简单，在连接数较少的时候非常有效，但是如果对每一个连接都产生一个线程的无疑是对系统资源的一种浪费，如果连接数较多将会出现资源不足的情况。</p><p><strong>项目实例:我这里放github里面了自己down下来理解</strong></p><p><strong>伪异步IO模型:</strong></p><p>为了改进这种一连接一线程的模型，我们可以使用线程池来管理这些线程，就相当于加了个缓冲区,实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型“。</p><p><img src="/images/socket/fakeAsy.png"></p><p>其实并没有解决前面提到的资源等待问题，依旧会等待Io操作完毕.<br>下面祭出心心念念的NIO</p><p><strong>NIO 模型:</strong><br>JavaNIO中引入了几个概念,chanel,buffer,selector<br><font color="red">传统的Io是面向字节流的，NIO是面向缓冲区的(即buffer)</font></p><p><strong>Buffer:</strong><br>Java NIO中的Buffer用于和NIO通道进行交互,缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。<br><strong>Chanel:</strong><br><img src="/images/socket/chanel.png"></p><p>Java NIO的通道类似流，但又有些不同：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的(InputStream,OutputStream分开的)。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>如上图所示，从通道读取数据到缓冲区，从缓冲区写入数据到通道。</p><p><strong>Selector:</strong></p><p>JavaNIO编程的基础是Selector，也就是多路复用，Selector会不断的轮询注册在Selector上的Channel，如果某个Channel上面发生读或写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取已经准备就绪的Channel集合，进行后续的I/O操作。</p><blockquote><p>jdk用epoll()取代了之前的selector,所以他并没有最大连接句柄的限制。也就是说，一个线程可以负责处理成千上万的客户端</p></blockquote><p>在NIO类库中加入Buffer对象，体现了新库与原IO的一个重要的区别。在面向流的IO中，可以将数据直接写入或读取到Stream对象中。在NIO库中，所有数据都是用缓冲区处理的（读写）。</p><p><img src="/images/socket/niomodel.png"></p><p><strong>AIO 模型:</strong></p><p>AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。<br>但是对AIO来说，则更加进了一步，它不是在IO准备好时再通知线程，而是在IO操作已经完成后，再给线程发出通知。因此AIO是不会阻塞的，此时我们的业务逻辑将变成一个回调函数，等待IO操作完成后，由系统自动触发。</p><div class="post-announce">感谢您的阅读，本文由 <a href="https://yellowrifle.github.io">YellowRifle</a> 版权所有。如若转载，请注明出处：YellowRifle（<a href="https://yellowrifle.github.io/2019/07/03/java/">https://yellowrifle.github.io/2019/07/03/java/</a>）</div><div class="post__prevs"><div class="post__prev"></div><div class="post__prev post__prev--right"><a href="/2019/07/13/android-mqtt/" title="Mqtt">Mqtt<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E6%9D%82%E9%A1%B9/">杂项</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Web/">Web</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Redis/">Redis</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Java/">Java</a><span class="block-list-count">7</span><ul class="block-list-child"><li class="block-list-item"><a class="block-list-link" href="/categories/Java/Java-Lock/">Java Lock</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Java/Java-Basic/">Java Basic</a><span class="block-list-count">3</span></li></ul></li><li class="block-list-item"><a class="block-list-link" href="/categories/Gradle/">Gradle</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Golang/">Golang</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Algorithm/">Algorithm</a><span class="block-list-count">3</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2020/09/01/hello-world/" title="Hello World"><div class="item__cover"><img src="undefined" alt="Hello World"></div><div class="item__info"><h3 class="item__title">Hello World</h3><span class="item__text">2020-09-01</span></div></a></li><li class="latest-post-item"><a href="/2019/11/11/%E9%98%BF%E9%87%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8/" title="阿里服务器使用"><div class="item__cover"><img src="images/杂项/alibaba/headindex.png" alt="阿里服务器使用"></div><div class="item__info"><h3 class="item__title">阿里服务器使用</h3><span class="item__text">2019-11-11</span></div></a></li><li class="latest-post-item"><a href="/2019/11/05/Sychronized/" title="Sychronized(对象锁)"><div class="item__cover"><img src="/images/lock/Sychronized/headindex.jpg" alt="Sychronized(对象锁)"></div><div class="item__info"><h3 class="item__title">Sychronized(对象锁)</h3><span class="item__text">2019-11-05</span></div></a></li><li class="latest-post-item"><a href="/2019/11/05/Volatile/" title="Volatile"><div class="item__cover"><img src="/images/lock/volatile/headindex.png" alt="Volatile"></div><div class="item__info"><h3 class="item__title">Volatile</h3><span class="item__text">2019-11-05</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Garbage-Collector/">Garbage Collector</a></li><li class="tag-item"><a class="tag-link" href="/tags/Gradle/">Gradle</a></li><li class="tag-item"><a class="tag-link" href="/tags/Lock/">Lock</a></li><li class="tag-item"><a class="tag-link" href="/tags/NIO/">NIO</a></li><li class="tag-item"><a class="tag-link" href="/tags/OOP/">OOP</a></li><li class="tag-item"><a class="tag-link" href="/tags/Redis/">Redis</a></li><li class="tag-item"><a class="tag-link" href="/tags/Sychronized/">Sychronized</a></li><li class="tag-item"><a class="tag-link" href="/tags/Volatile/">Volatile</a></li><li class="tag-item"><a class="tag-link" href="/tags/android/">android</a></li><li class="tag-item"><a class="tag-link" href="/tags/login/">login</a></li><li class="tag-item"><a class="tag-link" href="/tags/sort/">sort</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Chengdu, Sichuan Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>984367065@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/images/websource/avator.jpg" alt="logo" title="YellowRifle"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2019 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/YellowRifle" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="984367065@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>