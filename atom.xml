<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YellowRifle</title>
  
  <subtitle>YellowRifle Thinking</subtitle>
  <link href="https://yellowrifle.github.io/atom.xml" rel="self"/>
  
  <link href="https://yellowrifle.github.io/"/>
  <updated>2020-09-01T03:18:25.400Z</updated>
  <id>https://yellowrifle.github.io/</id>
  
  <author>
    <name>YellowRifle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yellowrifle.github.io/2020/09/01/hello-world/"/>
    <id>https://yellowrifle.github.io/2020/09/01/hello-world/</id>
    <published>2020-09-01T03:18:25.400Z</published>
    <updated>2020-09-01T03:18:25.400Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>阿里服务器使用</title>
    <link href="https://yellowrifle.github.io/2019/11/11/%E9%98%BF%E9%87%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>https://yellowrifle.github.io/2019/11/11/%E9%98%BF%E9%87%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8/</id>
    <published>2019-11-11T11:48:37.000Z</published>
    <updated>2019-11-12T06:14:24.733Z</updated>
    
    <content type="html"><![CDATA[<p>今天弄了个阿里的服务器,谈一下使用感想<br><img src="/images/%E6%9D%82%E9%A1%B9/alibaba/web.png"><br>首先快是真的,而且便宜114一年,如果不考虑翻墙的话就不要买国外的服务器了,阿里云真心性价比高</p><p>有个坑要说一下:<br><strong>阿里的服务器在外部有防火墙</strong></p><h3 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a>划重点</h3><p>默认只开放三个端口</p><ul><li>HTTPS:  443</li><li>HTTP:   80</li><li>TCP:    22</li></ul><p>由于个人习惯,用产品前从不看使用说明,不知道阿里外部有防火墙,所以搞了一下午的FTP,我就一直在奇怪,明明在centos里关了防火墙的为啥就不能访问?搞半天发现在外部有防火墙设置,我佛了<br><img src="/images/%E6%9D%82%E9%A1%B9/alibaba/wall.png"><br>我自己增加开放端口,这里我增加了tomcat,dubbo,zookeeper等一些端口</p><p>总的来说阿里的服务器很好用并且性价比很高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天弄了个阿里的服务器,谈一下使用感想&lt;br&gt;&lt;img src=&quot;/images/%E6%9D%82%E9%A1%B9/alibaba/web.png&quot;&gt;&lt;br&gt;首先快是真的,而且便宜114一年,如果不考虑翻墙的话就不要买国外的服务器了,阿里云真心性价比高&lt;/p&gt;
&lt;p&gt;有</summary>
      
    
    
    
    <category term="杂项" scheme="https://yellowrifle.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="服务器" scheme="https://yellowrifle.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Sychronized(对象锁)</title>
    <link href="https://yellowrifle.github.io/2019/11/05/Sychronized/"/>
    <id>https://yellowrifle.github.io/2019/11/05/Sychronized/</id>
    <published>2019-11-05T11:26:05.000Z</published>
    <updated>2019-11-10T07:09:07.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sychronized是什么"><a href="#Sychronized是什么" class="headerlink" title="Sychronized是什么?"></a>Sychronized是什么?</h2><h2 id="Sychronized实现原理"><a href="#Sychronized实现原理" class="headerlink" title="Sychronized实现原理"></a>Sychronized实现原理</h2><h2 id="Sychronized的使用方法及场景"><a href="#Sychronized的使用方法及场景" class="headerlink" title="Sychronized的使用方法及场景"></a>Sychronized的使用方法及场景</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Sychronized是什么&quot;&gt;&lt;a href=&quot;#Sychronized是什么&quot; class=&quot;headerlink&quot; title=&quot;Sychronized是什么?&quot;&gt;&lt;/a&gt;Sychronized是什么?&lt;/h2&gt;&lt;h2 id=&quot;Sychronized实现原理</summary>
      
    
    
    
    <category term="Java" scheme="https://yellowrifle.github.io/categories/Java/"/>
    
    <category term="Java Lock" scheme="https://yellowrifle.github.io/categories/Java/Java-Lock/"/>
    
    
    <category term="Sychronized" scheme="https://yellowrifle.github.io/tags/Sychronized/"/>
    
  </entry>
  
  <entry>
    <title>Volatile</title>
    <link href="https://yellowrifle.github.io/2019/11/05/Volatile/"/>
    <id>https://yellowrifle.github.io/2019/11/05/Volatile/</id>
    <published>2019-11-05T11:25:52.000Z</published>
    <updated>2019-11-11T06:27:36.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发编程的三个特性"><a href="#并发编程的三个特性" class="headerlink" title="并发编程的三个特性"></a>并发编程的三个特性</h2><p>volatile 虽然从字面意思上理解比较简单，但是在实际环境中能正确的使用该变量并不容易，只有了解其背后的原理，我们才能发挥出这个关键字的重要作用。在理解原理之前，我们有必要先了解一下并发编程中三个常见的概念：原子性、可见性和顺序一致性。</p><p><strong>原子性</strong><br>原子性理解比较简单，与数据库系统中原子性意思基本一致，即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>一个很经典的例子就是银行账户转账问题：<br>比如从账户 A 向账户 B 转 1000 元，那么必然包括 2 个操作：从账户 A 减去 1000 元，往账户 B 加上 1000 元。<br>试想一下，如果这 2 个操作不具备原子性，会造成什么样的后果。假如从账户 A 减去 1000 元之后，操作突然中止。然后又从 B 取出了 500 元，取出 500 元之后，再执行往账户 B 加上 1000 元的操作。这样就会导致账户 A 虽然减去了 1000 元，但是账户 B 没有收到这个转过来的 1000 元。<br>所以这 2 个操作必须要具备原子性才能保证不出现一些意外的问题。<br>同样地反映到并发编程中会出现什么结果呢？<br>举个最简单的例子，大家想一下假如为一个 64 位的变量赋值过程不具备原子性的话，会发生什么后果？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long i &#x3D; 9L;</span><br></pre></td></tr></table></figure><p>假若一个线程执行到这个语句时，我暂且假设为一个 64 位的变量赋值包括两个过程：为低 32 位赋值，为高 32 位赋值。那么就可能发生一种情况：当将低 32 位数值写入之后，突然被中断，而此时又有一个线程去读取 i 的值，那么读取到的就是错误的数据。</p><p><strong>可见性</strong><br>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>举个简单的例子，看下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;线程1执行的代码</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">i &#x3D; 10;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;线程2执行的代码</span><br><span class="line">j &#x3D; i;</span><br></pre></td></tr></table></figure><p> 　　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p><p>　　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p><p>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><p><strong>顺序一致性</strong><br>即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 0;              </span><br><span class="line">boolean flag &#x3D; false;</span><br><span class="line">i &#x3D; 1;                &#x2F;&#x2F;语句1  </span><br><span class="line">flag &#x3D; true;          &#x2F;&#x2F;语句2</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 int 型变量，定义了一个 boolean 类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句 1 是在语句 2 前面的，那么 JVM 在真正执行这段代码的时候会保证语句 1 一定会在语句 2 前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p><p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><p>比如上面的代码中，语句 1 和语句 2 谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句 2 先执行而语句 1 后执行。</p><h2 id="Volatile是什么"><a href="#Volatile是什么" class="headerlink" title="Volatile是什么?"></a>Volatile是什么?</h2><p>在Sun的JDK官方文档是这样形容volatile的：</p><p>The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes. A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable.</p><p>大意就说，如果一个变量加了volatile关键字，就会告诉编译器和JVM的内存模型：这个变量是对所有线程共享的、可见的，每次jvm都会读取最新写入的值并使其最新值在所有CPU可见。volatile似乎是有时候可以代替简单的锁，似乎加了volatile关键字就省掉了锁。但又说volatile不能保证原子性（java程序员很熟悉这句话：volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性）。</p><h2 id="Volatile实现原理"><a href="#Volatile实现原理" class="headerlink" title="Volatile实现原理"></a>Volatile实现原理</h2><p><img src="/images/lock/volatile/volatile.png"></p><h2 id="常见问题-volatile为什么不能保证原子性"><a href="#常见问题-volatile为什么不能保证原子性" class="headerlink" title="常见问题 volatile为什么不能保证原子性"></a>常见问题 volatile为什么不能保证原子性</h2><p>就比如在多线程中，多个线程对于一个实例变量的变量i进行自增操作，例如i++，这时候就产生了竞态条件导致，例如给i变量加5000次，得到的结果可能是5000得到的结果也可能是少于5000，尽管你加了volatile，这是为什么呢？要知道volatile仅是通过内存屏障的机制来保障</p><p>例如</p><p>load1;load2;store1;store2;StoreLoad;load3;store3…..</p><p>尽管你保证了可见性，但你不能保证该操作的原子性，所谓的原子性本质就是指令在执行期间不被打断，要么就是不执行，仔细想想i++是不是一个三步的复合操作：取值、相加、赋值，就比如：你在未赋值时别的线程执行时，别的线程也正在处以赋值状态,尽管你保障了可见性，但你并不能保证你拿到手上的值永远是最新值</p><h2 id="Volatile的使用方法及场景"><a href="#Volatile的使用方法及场景" class="headerlink" title="Volatile的使用方法及场景"></a>Volatile的使用方法及场景</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;并发编程的三个特性&quot;&gt;&lt;a href=&quot;#并发编程的三个特性&quot; class=&quot;headerlink&quot; title=&quot;并发编程的三个特性&quot;&gt;&lt;/a&gt;并发编程的三个特性&lt;/h2&gt;&lt;p&gt;volatile 虽然从字面意思上理解比较简单，但是在实际环境中能正确的使用该变量并</summary>
      
    
    
    
    <category term="Java" scheme="https://yellowrifle.github.io/categories/Java/"/>
    
    <category term="Java Basic" scheme="https://yellowrifle.github.io/categories/Java/Java-Basic/"/>
    
    
    <category term="Volatile" scheme="https://yellowrifle.github.io/tags/Volatile/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://yellowrifle.github.io/2019/11/05/ThreadLocal/"/>
    <id>https://yellowrifle.github.io/2019/11/05/ThreadLocal/</id>
    <published>2019-11-05T11:25:28.000Z</published>
    <updated>2019-11-10T07:05:50.827Z</updated>
    
    
    
    
    <category term="Java" scheme="https://yellowrifle.github.io/categories/Java/"/>
    
    <category term="Java Lock" scheme="https://yellowrifle.github.io/categories/Java/Java-Lock/"/>
    
    
    <category term="Sychronized" scheme="https://yellowrifle.github.io/tags/Sychronized/"/>
    
  </entry>
  
  <entry>
    <title>Gradle多项目依赖</title>
    <link href="https://yellowrifle.github.io/2019/11/05/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/"/>
    <id>https://yellowrifle.github.io/2019/11/05/Gradle%E5%A4%9A%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/</id>
    <published>2019-11-05T06:49:58.000Z</published>
    <updated>2019-11-05T09:11:09.873Z</updated>
    
    
    
    
    <category term="Gradle" scheme="https://yellowrifle.github.io/categories/Gradle/"/>
    
    
    <category term="Gradle" scheme="https://yellowrifle.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>谈谈面向对象</title>
    <link href="https://yellowrifle.github.io/2019/11/05/%E8%B0%88%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://yellowrifle.github.io/2019/11/05/%E8%B0%88%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2019-11-05T06:47:57.000Z</published>
    <updated>2019-11-12T06:17:38.252Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中面向对象是一个重要的特性，Java中的一切皆为对象，这一重要特性使Java在企业级应用中广受欢迎（模块易抽象，方便分工合作）<br>但于此同时缺点就是冗余，对于复杂的程序它让程序管理变得清晰，但简单程序就显得冗余了些</p><p>再看看其他语言，Python也支持面向对象的程序，Python写的比较少，个人感觉这个语言更加适合科学计算等一些小型应用，由于众多的支持库使这些小功能变得非常方便，对于大型应用python 确实显得有些慢了。</p><p>Java面向对象的实现<br>Java中有 继承 接口等设计<br>Java中和面向对象有关的有 类，继承，接口</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Java中面向对象是一个重要的特性，Java中的一切皆为对象，这一重要特性使Java在企业级应用中广受欢迎（模块易抽象，方便分工合作）&lt;br&gt;但于此同时缺点就是冗余，对于复杂的程序它让程序管理变得清晰，但简单程序就显得冗余了些&lt;/p&gt;
&lt;p&gt;再看看其他语言，Python也</summary>
      
    
    
    
    <category term="Java" scheme="https://yellowrifle.github.io/categories/Java/"/>
    
    <category term="Java Basic" scheme="https://yellowrifle.github.io/categories/Java/Java-Basic/"/>
    
    
    <category term="OOP" scheme="https://yellowrifle.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收</title>
    <link href="https://yellowrifle.github.io/2019/11/05/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://yellowrifle.github.io/2019/11/05/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2019-11-05T06:47:40.000Z</published>
    <updated>2019-11-17T06:22:15.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h1><h3 id="一、垃圾检测算法"><a href="#一、垃圾检测算法" class="headerlink" title="一、垃圾检测算法"></a>一、垃圾检测算法</h3><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h4><p>这种方法实际上就是用了计数器,当一个对象被引用后,计数器+1,当引用失效后计数器-1,当计数器为0时,就表明这个对象已经可以被回收了.<br>引用计数法实现简单，判定效率高。<font color = red>但是目前来讲Java的垃圾回收器是没有实现这个算法的。</font>因为当栈里没有引用的话，可能堆里几个内存块相互引用，这样虽然是垃圾，但是引用计数法却不能判断此为垃圾，因为它们相互引用，计数不为0</p><h4 id="2-可达性判断"><a href="#2-可达性判断" class="headerlink" title="2.可达性判断"></a>2.可达性判断</h4><p>这个算法的基本思想是通过一系列称为<font color = red>“GC Roots”</font>的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。</p><p><strong>GCRoots的对象包括下面几种：</strong></p><ul><li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。</li><li>方法区中的类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI(Native方法)引用的对象</li></ul><h4 id="引用类型："><a href="#引用类型：" class="headerlink" title="引用类型："></a>引用类型：</h4><p><strong>⑴强引用（StrongReference）</strong><br>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  ps：强引用其实也就是我们平时A a = new A()这个意思。</p><p><strong>⑵软引用（SoftReference）</strong><br>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>⑶弱引用（WeakReference）</strong><br>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>⑷虚引用（PhantomReference）</strong><br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p><p>ReferenceQueue queue = new ReferenceQueue ();</p><p>PhantomReference pr = new PhantomReference (object, queue);<br><img src="/images/garbage/yingyong.png"></p><h3 id="二、回收算法"><a href="#二、回收算法" class="headerlink" title="二、回收算法"></a>二、回收算法</h3><p><font color=#f1939c>回收算法有很多种,java中采用的是分代回收算法.</font><br>按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率。<br><strong>方法区的回收</strong><br>1.废弃的常量：不可达的常量。<br>2.无用的类。 </p><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法:"></a>回收算法:</h4><p><strong>1、标记清除(Mark-and-Sweep):</strong><br><img src="/images/garbage/Normal-Deletion-Mark-and-Sweep.png"><br>process:直接将之前标记的垃圾清除<br>problem:会产生很多的垃圾碎片,影响内存分配　</p><p><strong>２、标记整理(Mark-and-Sweep):</strong><br><img src="/images/garbage/Deletion-with-compacting.png"><br>垃圾清理后，整理得到完整的内存空间</p><p><strong>3、标记复制(Copying):</strong><br><img src="/images/garbage/Deletion-with-copying-Mark-and-Sweep.png"><br>保证内存利用效率<br>###三、垃圾回收器<br><img src="/images/garbage/collector.png"><br>新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge。<br>老年代收集器使用的收集器：Serial Old、Parallel Old、CMS。<br><strong>着重说一下CMS和G1</strong><br><strong>CMS</strong>:<br>多线程扫描堆区的垃圾回收器<br>defect:</p><ul><li>采用标记清除法,有碎片</li><li>无法清除浮动垃圾(回收时还会有新的垃圾产生，这部分垃圾叫做浮动垃圾)</li></ul><p><strong>G1:</strong></p><p><img src="/images/garbage/Memory-regions-marked-G1.png"><br>将堆区又进行了更小的拆分(约为2048)个region,每个region都有标记的年轻代和老年代</p><p>Java 8 parallec GC是默认收集算法<br>java 9 G1被设置为默认收集算法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java垃圾回收&quot;&gt;&lt;a href=&quot;#Java垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;Java垃圾回收&quot;&gt;&lt;/a&gt;Java垃圾回收&lt;/h1&gt;&lt;h3 id=&quot;一、垃圾检测算法&quot;&gt;&lt;a href=&quot;#一、垃圾检测算法&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Java" scheme="https://yellowrifle.github.io/categories/Java/"/>
    
    <category term="Golang" scheme="https://yellowrifle.github.io/categories/Golang/"/>
    
    
    <category term="Garbage Collector" scheme="https://yellowrifle.github.io/tags/Garbage-Collector/"/>
    
  </entry>
  
  <entry>
    <title>Redis用法</title>
    <link href="https://yellowrifle.github.io/2019/11/05/Redis%E7%94%A8%E6%B3%95/"/>
    <id>https://yellowrifle.github.io/2019/11/05/Redis%E7%94%A8%E6%B3%95/</id>
    <published>2019-11-05T06:47:06.000Z</published>
    <updated>2019-11-12T06:18:38.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis的5种基本数据结构"><a href="#Redis的5种基本数据结构" class="headerlink" title="Redis的5种基本数据结构"></a>Redis的5种基本数据结构</h2><h3 id="String字符串类型"><a href="#String字符串类型" class="headerlink" title="String字符串类型"></a>String字符串类型</h3><h3 id="List列表类型"><a href="#List列表类型" class="headerlink" title="List列表类型"></a>List列表类型</h3><h3 id="Hash数据类型"><a href="#Hash数据类型" class="headerlink" title="Hash数据类型"></a>Hash数据类型</h3><h3 id="Set集合类型"><a href="#Set集合类型" class="headerlink" title="Set集合类型"></a>Set集合类型</h3><h3 id="Zset有序集合"><a href="#Zset有序集合" class="headerlink" title="Zset有序集合"></a>Zset有序集合</h3><p>排序集合</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis的5种基本数据结构&quot;&gt;&lt;a href=&quot;#Redis的5种基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;Redis的5种基本数据结构&quot;&gt;&lt;/a&gt;Redis的5种基本数据结构&lt;/h2&gt;&lt;h3 id=&quot;String字符串类型&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Redis" scheme="https://yellowrifle.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://yellowrifle.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>web架构</title>
    <link href="https://yellowrifle.github.io/2019/11/05/web%E6%9E%B6%E6%9E%84/"/>
    <id>https://yellowrifle.github.io/2019/11/05/web%E6%9E%B6%E6%9E%84/</id>
    <published>2019-11-05T06:46:20.000Z</published>
    <updated>2019-11-05T09:10:17.905Z</updated>
    
    
    
    
    <category term="Web" scheme="https://yellowrifle.github.io/categories/Web/"/>
    
    
    <category term="login" scheme="https://yellowrifle.github.io/tags/login/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://yellowrifle.github.io/2019/11/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://yellowrifle.github.io/2019/11/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2019-11-04T13:53:29.000Z</published>
    <updated>2019-11-06T03:02:45.461Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @author YellowRifle</span><br><span class="line"> * @projectName DataStructure</span><br><span class="line"> * @description: TODO</span><br><span class="line"> * @create 19-7-1下午12:08</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void mergingSort()&#123;</span><br><span class="line">        int a[]&#x3D;&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;;</span><br><span class="line">        sort(a,0,a.length-1);</span><br><span class="line">        for(int i&#x3D;0;i&lt;a.length;i++) &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sort(int[] data, int left, int right) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        if(left&lt;right)&#123;</span><br><span class="line">            &#x2F;&#x2F;找出中间索引</span><br><span class="line">            int center&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            &#x2F;&#x2F;对左边数组进行递归</span><br><span class="line">            sort(data,left,center);</span><br><span class="line">            &#x2F;&#x2F;对右边数组进行递归</span><br><span class="line">            sort(data,center+1,right);</span><br><span class="line">            &#x2F;&#x2F;合并</span><br><span class="line">            merge(data,left,center,right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void merge(int[] data, int left, int center, int right) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        int [] tmpArr&#x3D;new int[data.length];</span><br><span class="line">        int mid&#x3D;center+1;</span><br><span class="line">        &#x2F;&#x2F;third记录中间数组的索引</span><br><span class="line">        int third&#x3D;left;</span><br><span class="line">        int tmp&#x3D;left;</span><br><span class="line">        while(left&lt;&#x3D;center&amp;&amp;mid&lt;&#x3D;right)&#123;</span><br><span class="line">            &#x2F;&#x2F;从两个数组中取出最小的放入中间数组</span><br><span class="line">            if(data[left]&lt;&#x3D;data[mid])&#123;</span><br><span class="line">                tmpArr[third++]&#x3D;data[left++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                tmpArr[third++]&#x3D;data[mid++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;剩余部分依次放入中间数组</span><br><span class="line">        while(mid&lt;&#x3D;right)&#123;</span><br><span class="line">            tmpArr[third++]&#x3D;data[mid++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(left&lt;&#x3D;center)&#123;</span><br><span class="line">            tmpArr[third++]&#x3D;data[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将中间数组中的内容复制回原数组</span><br><span class="line">        while(tmp&lt;&#x3D;right)&#123;</span><br><span class="line">            data[tmp]&#x3D;tmpArr[tmp++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        mergingSort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yellowrifle.github.io/categories/Algorithm/"/>
    
    
    <category term="sort" scheme="https://yellowrifle.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://yellowrifle.github.io/2019/11/04/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://yellowrifle.github.io/2019/11/04/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2019-11-04T13:53:20.000Z</published>
    <updated>2019-11-05T11:46:06.842Z</updated>
    
    <content type="html"><![CDATA[<iframe src="/images/algorithm/sort/quickSort.gif" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe><h3 id="快排3步走"><a href="#快排3步走" class="headerlink" title="快排3步走"></a>快排3步走</h3><h4 id="Step1-选取Base基点"><a href="#Step1-选取Base基点" class="headerlink" title="Step1: 选取Base基点"></a>Step1: 选取Base基点</h4><pre><code>采用简单的方法取每次排列数组的第一个点,Base的选取同样有很多优化,可以到网上找些教程同时申明变量 向后查找游标为i,向前查找节点坐标为j</code></pre><h4 id="Step2-从后向前找小于Base的点"><a href="#Step2-从后向前找小于Base的点" class="headerlink" title="Step2: 从后向前找小于Base的点"></a>Step2: 从后向前找小于Base的点</h4><pre><code>找到 -------&gt;array[i] = array[j]</code></pre><h4 id="Step3-从前向后找大于Base的点-查找游标为j"><a href="#Step3-从前向后找大于Base的点-查找游标为j" class="headerlink" title="Step3: 从前向后找大于Base的点(查找游标为j)"></a>Step3: 从前向后找大于Base的点(查找游标为j)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package algorithm.innersort;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author YellowRifle</span><br><span class="line"> * @projectName DataStructure</span><br><span class="line"> * @description: TODO</span><br><span class="line"> * @create 19-7-1上午9:30</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;采用递归实现</span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array &#x3D; &#123;1,3,1,3,4,6,7,89,2,432,523,421,9,6&#125;;</span><br><span class="line">        order(array,0,array.length-1);</span><br><span class="line">        for (int i : array) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void order(int[] array,int low,int high)&#123;</span><br><span class="line">        if (low &gt; high)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D; low;</span><br><span class="line">        int j &#x3D; high;</span><br><span class="line">        int base &#x3D; array[low];</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            while(array[j] &gt;&#x3D; base &amp;&amp; j &gt; i)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j) &#123;</span><br><span class="line">                array[i++]  &#x3D; array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            while (array[i] &lt;&#x3D; base &amp;&amp; j &gt; i) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; j) &#123;</span><br><span class="line">                array[j--] &#x3D; array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            array[i] &#x3D; base;</span><br><span class="line">            order(array,low,i-1);</span><br><span class="line">            order(array,i+1,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe src=&quot;/images/algorithm/sort/quickSort.gif&quot; width=&quot;100%&quot; height=&quot;300&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yellowrifle.github.io/categories/Algorithm/"/>
    
    
    <category term="sort" scheme="https://yellowrifle.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://yellowrifle.github.io/2019/11/04/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://yellowrifle.github.io/2019/11/04/%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2019-11-04T13:53:10.000Z</published>
    <updated>2019-11-06T03:02:43.713Z</updated>
    
    <content type="html"><![CDATA[<p>创建堆</p><iframe src="/images/algorithm/sort/heapBu.gif" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe><p>调整堆</p><iframe src="/images/algorithm/sort/heapAd.gif" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    package algorithm.innersort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author YellowRifle</span><br><span class="line"> * @projectName DataStructure</span><br><span class="line"> * @description: TODO</span><br><span class="line"> * @create 19-7-11下午10:51</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line">&#x2F;最大堆排序</span><br><span class="line">采用下沉算法</span><br><span class="line">上浮运算次数要多一点</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class HeapSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] a &#x3D; &#123;51,32,73,23,42,62&#125;;</span><br><span class="line">        heapSort(a);</span><br><span class="line">        for (int i : a) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void heapSort(int[] array) &#123;</span><br><span class="line">        int n &#x3D; array.length - 1;</span><br><span class="line">        for (int i &#x3D; array.length-1 &#x2F; 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            sink(i ,n,array);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (n &gt; 0) &#123;</span><br><span class="line">            swap(array,0, n);</span><br><span class="line">            n --;</span><br><span class="line">            sink(0,n ,array);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private static void swap(int[] array, int i, int j) &#123;</span><br><span class="line">        int temp &#x3D; array[i];</span><br><span class="line">        array[i] &#x3D; array[j];</span><br><span class="line">        array[j] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    private static boolean getLess(int[] array, int i, int j) &#123;</span><br><span class="line">        return array[i] &lt; array[j];</span><br><span class="line">    &#125;</span><br><span class="line">    static void sink(int i, int n, int[] array) &#123;</span><br><span class="line">        while (2 * i &lt; n) &#123;</span><br><span class="line">            int child &#x3D; i * 2 + 1;</span><br><span class="line">            if (child &lt; n &amp;&amp; getLess(array,child,child + 1)) &#123;</span><br><span class="line">                child ++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (getLess(array,i,child)) &#123;</span><br><span class="line">                swap(array,i,child);</span><br><span class="line">                i &#x3D; child;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建堆&lt;/p&gt;
&lt;iframe src=&quot;/images/algorithm/sort/heapBu.gif&quot; width=&quot;100%&quot; height=&quot;300&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yellowrifle.github.io/categories/Algorithm/"/>
    
    
    <category term="sort" scheme="https://yellowrifle.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>单点登录</title>
    <link href="https://yellowrifle.github.io/2019/11/04/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://yellowrifle.github.io/2019/11/04/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2019-11-04T13:52:58.000Z</published>
    <updated>2019-11-10T06:51:31.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、业务介绍来源"><a href="#一、业务介绍来源" class="headerlink" title="一、业务介绍来源"></a>一、业务介绍来源</h2><h4 id="早期单一服务器，用户认证"><a href="#早期单一服务器，用户认证" class="headerlink" title="早期单一服务器，用户认证"></a>早期单一服务器，用户认证</h4><p><strong>缺点：单点性能压力，无法扩展</strong><br>早期我们开发web应用都是所有的包放在一起打成一个war包放入tomcat容器来运行的,所有的功能,所有的业务,后台管理,门户界面,都是由这一个war来支持的。</p><p>用户的登录以及权限就显得十分简单,用户登录成功后,把相关信息放入会话中,HTTP维护这个会话,再每次用户请求服务器的时候来验证这个会话即可,大致可以用下图来表示:<br><img src="/images/web/sso/oldMethod.png"></p><p>服务器和客户端的状态是由session来维护的,当集群出现后,各台机器上的Session就会出现不一致的问题,下面来梳理下Session。</p><p><strong>Token和Session</strong><br><em>Session:</em><br>客户端首次请求,服务器生成sessionId,存在服务器上,同时发送一份到客户端,客户端保存在浏览器中,下次访问的时候带上sessionId去访问(放在header里)，服务器验证比对是否存有改Id就能够判断曾经登录与否</p><p><strong>Session存在什么问题:</strong></p><ul><li>cookie中使用jsessionId 容易被篡改、盗取,不法分子直接可以从浏览器中截取出保存的JsessionId,直接可用于登录</li><li>用户量大时空间浪费高</li><li>跨顶级域名无法访问</li><li>严重的限制了服务器扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统，  那session id会保存在机器A上，  假设小F的下一次请求被转发到机器B怎么办？  机器B可没有小F的 session id啊。</li></ul><p><strong>Token流程:</strong><br>1.用户通过用户名和密码发送请求。<br>2.程序验证。<br>3.程序返回一个签名的token 给客户端。<br>4.客户端储存token,并且每次用于每次发送请求。<br>5.服务端验证token并返回数据。</p><p><strong>发现Token和Session的区别了吗?</strong><br>Token并不会在服务器上进行保存,而是在服务器上有一套验证逻辑,下一次登录服务器只需要对客户端发来的token进行合法性验证就好了,而session是需要在服务器中保存一个值,服务器对比和客户端请求的值的是否一致。<br>Token:时间换空间<br>Session:空间换时间(社区合法性验证过程)<br><strong>注意这里Session和web中的Session有区别</strong></p><h4 id="SSO单点登录模式-single-sign-on"><a href="#SSO单点登录模式-single-sign-on" class="headerlink" title="SSO单点登录模式(single sign on)"></a>SSO单点登录模式(single sign on)</h4><p>解决了单点性能瓶颈<br>系统架构:<br><img src="/images/web/sso/ssoindex.png"><br><img src="/images/web/sso/sso.png"></p><h2 id="二、实现单点登录"><a href="#二、实现单点登录" class="headerlink" title="二、实现单点登录"></a>二、实现单点登录</h2><h4 id="Step1-生成token"><a href="#Step1-生成token" class="headerlink" title="Step1: 生成token"></a>Step1: 生成token</h4><h5 id="JWT工具"><a href="#JWT工具" class="headerlink" title="JWT工具"></a>JWT工具</h5><p>JWT（Json Web Token） 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。<br>JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上<br>JWT 最重要的作用就是对 token信息的防伪作用。</p><h5 id="JWT的组成"><a href="#JWT的组成" class="headerlink" title="JWT的组成"></a>JWT的组成</h5><p>一个JWT由三个部分组成：公共部分、私有部分、签名部分。最后由这三者组合进行base64编码得到JWT。<br><img src="/images/web/sso/jwt.jpeg"></p><p>1、公共部分(Header)<br>主要是该JWT的相关配置参数，比如签名的加密算法、格式类型、过期时间等等。<br>2、私有部分(Payload)<br>用户自定义的内容，根据实际需要真正要封装的信息。<br>3、签名部分(Signature)<br>根据用户信息+盐值+密钥生成的签名。如果想知道JWT是否是真实的只要把JWT的信息取出来，加上盐值和服务器中的密钥就可以验证真伪。所以不管由谁保存JWT，只要没有密钥就无法伪造。<br>4、base64编码，并不是加密，只是把明文信息变成了不可见的字符串。但是其实只要用一些工具就可以吧base64编码解成明文，所以不要在JWT中放入涉及私密的信息，因为实际上JWT并不是加密信息。<br>5、采用HMAC-SHA256进行Hsh加密</p><h4 id="Step2-制作-JWT的工具类（JwtUtil）"><a href="#Step2-制作-JWT的工具类（JwtUtil）" class="headerlink" title="Step2: 制作 JWT的工具类（JwtUtil）"></a>Step2: 制作 JWT的工具类（JwtUtil）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    public class JwtUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static String encode(String key,Map&lt;String,Object&gt; param,String salt)&#123;</span><br><span class="line">        if(salt!&#x3D;null)&#123;</span><br><span class="line">            key+&#x3D;salt;</span><br><span class="line">        &#125;</span><br><span class="line">        JwtBuilder jwtBuilder &#x3D; Jwts.builder().signWith(SignatureAlgorithm.HS256,key);</span><br><span class="line"></span><br><span class="line">        jwtBuilder &#x3D; jwtBuilder.setClaims(param);</span><br><span class="line"></span><br><span class="line">        String token &#x3D; jwtBuilder.compact();</span><br><span class="line">        return token;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public  static Map&lt;String,Object&gt;  decode(String token ,String key,String salt)&#123;</span><br><span class="line">        Claims claims&#x3D;null;</span><br><span class="line">        if (salt!&#x3D;null)&#123;</span><br><span class="line">            key+&#x3D;salt;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            claims&#x3D; Jwts.parser().setSigningKey(key).parseClaimsJws(token).getBody();</span><br><span class="line">        &#125; catch ( JwtException e) &#123;</span><br><span class="line">           return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return  claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Step3-建立注册中心"><a href="#Step3-建立注册中心" class="headerlink" title="Step3: 建立注册中心"></a>Step3: 建立注册中心</h4><p>实际项目中,可建立一个模块用作注册中心,如我这里的passport作为注册中心。<br>注册中心主要功能:</p><p><strong>1.验证用户是否合法</strong><br><strong>2.为登录用户颁发token</strong><br><img src="/images/web/sso/passport.png"></p><p>#####登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;login&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String login(UmsMember umsMember, HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line">        String token &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 调用用户服务验证用户名和密码</span><br><span class="line">        UmsMember umsMemberLogin &#x3D; userService.login(umsMember);</span><br><span class="line"></span><br><span class="line">        if(umsMemberLogin!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F; 登录成功</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 用jwt制作token</span><br><span class="line">            String memberId &#x3D; umsMemberLogin.getId();</span><br><span class="line">            String nickname &#x3D; umsMemberLogin.getNickname();</span><br><span class="line">            Map&lt;String,Object&gt; userMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">            userMap.put(&quot;memberId&quot;,memberId);</span><br><span class="line">            userMap.put(&quot;nickname&quot;,nickname);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            String ip &#x3D; request.getHeader(&quot;x-forwarded-for&quot;);&#x2F;&#x2F; 通过nginx转发的客户端ip</span><br><span class="line">            if(StringUtils.isBlank(ip))&#123;</span><br><span class="line">                ip &#x3D; request.getRemoteAddr();&#x2F;&#x2F; 从request中获取ip</span><br><span class="line">                if(StringUtils.isBlank(ip))&#123;</span><br><span class="line">                    ip &#x3D; &quot;127.0.0.1&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 按照设计的算法对参数进行加密后，生成token</span><br><span class="line">            token &#x3D; JwtUtil.encode(&quot;2019gmall0105&quot;, userMap, ip);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 将token存入redis一份</span><br><span class="line">            userService.addUserToken(token,memberId);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F; 登录失败</span><br><span class="line">            token &#x3D; &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>#####验证token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;verify&quot;)</span><br><span class="line">   @ResponseBody</span><br><span class="line">   public String verify(String token,String currentIp,HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 通过jwt校验token真假</span><br><span class="line">       Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       Map&lt;String, Object&gt; decode &#x3D; JwtUtil.decode(token, &quot;2019gmall0105&quot;, currentIp);</span><br><span class="line"></span><br><span class="line">       if(decode!&#x3D;null)&#123;</span><br><span class="line">           map.put(&quot;status&quot;,&quot;success&quot;);</span><br><span class="line">           map.put(&quot;memberId&quot;,(String)decode.get(&quot;memberId&quot;));</span><br><span class="line">           map.put(&quot;nickname&quot;,(String)decode.get(&quot;nickname&quot;));</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           map.put(&quot;status&quot;,&quot;fail&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       return JSON.toJSONString(map);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#####跳转到index登录界面,登录失败时使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;index&quot;)</span><br><span class="line">   public String index(String ReturnUrl, ModelMap map)&#123;</span><br><span class="line"></span><br><span class="line">       map.put(&quot;ReturnUrl&quot;,ReturnUrl);</span><br><span class="line">       return &quot;index&quot;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Step3-业务模块的登录检查-注解与拦截器"><a href="#Step3-业务模块的登录检查-注解与拦截器" class="headerlink" title="Step3: 业务模块的登录检查(@注解与拦截器)"></a>Step3: 业务模块的登录检查(@注解与拦截器)</h4><p>1 、由认证中心签发的token如何保存？保存到浏览器的cookie中<br>     2 、难道每一个模块都要做一个token的保存功能？ 拦截器<br>     3 、如何区分请求是否一定要登录？自定义注解</p><h5 id="拦截器-Interceptor"><a href="#拦截器-Interceptor" class="headerlink" title="拦截器(Interceptor)"></a>拦截器(Interceptor)</h5><p>拦截器原理基于反射,网上很多教程,要注意之前servlet中用过的Fliter和Interceptor(拦截器)的区别—–&gt;<strong>一个是反射,一个是和Servlet有关</strong></p><p><strong>HandlerInterceptor-&gt;Spring中提供的拦截器接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    public interface HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">     * 预处理回调方法，实现处理器的预处理（如检查登陆），第三个参数为响应的处理器，自定义Controller</span><br><span class="line">     * 返回值：true表示继续流程（如调用下一个拦截器或处理器）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；</span><br><span class="line">   *&#x2F;</span><br><span class="line">    boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">            throws Exception;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">     * 后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</span><br><span class="line">   *&#x2F;</span><br><span class="line">    void postHandle(</span><br><span class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span><br><span class="line">            throws Exception;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中</span><br><span class="line">   *&#x2F;</span><br><span class="line">    void afterCompletion(</span><br><span class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span><br><span class="line">            throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、定义登录检查注解<br><strong>LoginRequired.class:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface LoginRequired &#123;</span><br><span class="line"></span><br><span class="line">    boolean loginSuccess() default true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、自定义拦截器，继承成HandlerInterceptorAdapter,通过重写它的preHandle方法，业务代码前的校验工作<br><strong>AuthInterceptor.class:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AuthInterceptor extends HandlerInterceptorAdapter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 拦截代码</span><br><span class="line">        &#x2F;&#x2F; 判断被拦截的请求的访问的方法的注解(是否时需要拦截的)</span><br><span class="line">        HandlerMethod hm &#x3D; (HandlerMethod) handler;</span><br><span class="line">        LoginRequired methodAnnotation &#x3D; hm.getMethodAnnotation(LoginRequired.class);</span><br><span class="line"></span><br><span class="line">        StringBuffer url &#x3D; request.getRequestURL();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 没有LoginRequired则直接放行</span><br><span class="line">        if (methodAnnotation &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;先从cookie中查找有没有保存的token信息</span><br><span class="line">        String token &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        String oldToken &#x3D; CookieUtil.getCookieValue(request, &quot;oldToken&quot;, true);</span><br><span class="line">        if (StringUtils.isNotBlank(oldToken)) &#123;</span><br><span class="line">            token &#x3D; oldToken;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String newToken &#x3D; request.getParameter(&quot;token&quot;);</span><br><span class="line">        if (StringUtils.isNotBlank(newToken)) &#123;</span><br><span class="line">            token &#x3D; newToken;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 是否必须登录</span><br><span class="line">        boolean loginSuccess &#x3D; methodAnnotation.loginSuccess();&#x2F;&#x2F; 获得该请求是否必登录成功</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 进入认证中心进行验证</span><br><span class="line">        String success &#x3D; &quot;fail&quot;;</span><br><span class="line">        Map&lt;String,String&gt; successMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        if(StringUtils.isNotBlank(token))&#123;</span><br><span class="line">            String ip &#x3D; request.getHeader(&quot;x-forwarded-for&quot;);&#x2F;&#x2F; 通过nginx转发的客户端ip</span><br><span class="line">            if(StringUtils.isBlank(ip))&#123;</span><br><span class="line">                ip &#x3D; request.getRemoteAddr();&#x2F;&#x2F; 从request中获取ip</span><br><span class="line">                if(StringUtils.isBlank(ip))&#123;</span><br><span class="line">                    ip &#x3D; &quot;127.0.0.1&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String successJson  &#x3D; HttpclientUtil.doGet(&quot;http:&#x2F;&#x2F;passport.gmall.com:8085&#x2F;verify?token&#x3D;&quot; + token+&quot;&amp;currentIp&#x3D;&quot;+ip);</span><br><span class="line"></span><br><span class="line">            successMap &#x3D; JSON.parseObject(successJson,Map.class);</span><br><span class="line"></span><br><span class="line">            success &#x3D; successMap.get(&quot;status&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (loginSuccess) &#123;</span><br><span class="line">            &#x2F;&#x2F; 必须登录成功才能使用</span><br><span class="line">            if (!success.equals(&quot;success&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F;重定向会passport登录</span><br><span class="line">                StringBuffer requestURL &#x3D; request.getRequestURL();</span><br><span class="line">                response.sendRedirect(&quot;http:&#x2F;&#x2F;passport.gmall.com:8085&#x2F;index?ReturnUrl&#x3D;&quot;+requestURL);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 需要将token携带的用户信息写入</span><br><span class="line">            request.setAttribute(&quot;memberId&quot;, successMap.get(&quot;memberId&quot;));</span><br><span class="line">            request.setAttribute(&quot;nickname&quot;, successMap.get(&quot;nickname&quot;));</span><br><span class="line">            &#x2F;&#x2F;验证通过，覆盖cookie中的token</span><br><span class="line">            if(StringUtils.isNotBlank(token))&#123;</span><br><span class="line">                CookieUtil.setCookie(request,response,&quot;oldToken&quot;,token,60*60*2,true);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 没有登录也能用，但是必须验证</span><br><span class="line">            if (success.equals(&quot;success&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 需要将token携带的用户信息写入</span><br><span class="line">                request.setAttribute(&quot;memberId&quot;, successMap.get(&quot;memberId&quot;));</span><br><span class="line">                request.setAttribute(&quot;nickname&quot;, successMap.get(&quot;nickname&quot;));</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;验证通过，覆盖cookie中的token</span><br><span class="line">                if(StringUtils.isNotBlank(token))&#123;</span><br><span class="line">                    CookieUtil.setCookie(request,response,&quot;oldToken&quot;,token,60*60*2,true);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CookieUtil等工具包地址<br><a href="https://github.com/YellowRifle/Web-Utils">https://github.com/YellowRifle/Web-Utils</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、业务介绍来源&quot;&gt;&lt;a href=&quot;#一、业务介绍来源&quot; class=&quot;headerlink&quot; title=&quot;一、业务介绍来源&quot;&gt;&lt;/a&gt;一、业务介绍来源&lt;/h2&gt;&lt;h4 id=&quot;早期单一服务器，用户认证&quot;&gt;&lt;a href=&quot;#早期单一服务器，用户认证&quot; cla</summary>
      
    
    
    
    <category term="Web" scheme="https://yellowrifle.github.io/categories/Web/"/>
    
    
    <category term="login" scheme="https://yellowrifle.github.io/tags/login/"/>
    
  </entry>
  
  <entry>
    <title>ReetrantLock的看法</title>
    <link href="https://yellowrifle.github.io/2019/10/23/ReetrantLock/"/>
    <id>https://yellowrifle.github.io/2019/10/23/ReetrantLock/</id>
    <published>2019-10-23T02:24:16.000Z</published>
    <updated>2019-11-10T07:06:53.656Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Lock是一个接口,其有很多种实现,Lock和sychronized关键词不同,Lock依赖aqs实现锁,没有应用到底层jvm等相关的技术,更适合应用层的扩展,实现方式很多,更方便更加灵活。</strong></p><h4 id="ReetrantLock"><a href="#ReetrantLock" class="headerlink" title="ReetrantLock:"></a>ReetrantLock:</h4><p>实现了Lock接口<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/images/lock/ReetrantLock/rlock.png"></p><p><strong>内部方法:</strong><br>内部方法基本上都是由AQS(AbstractQueuedSynchronizer),这里有2个比较重要的类<br><img src="/images/lock/ReetrantLock/structure.png"></p><ul><li>FairSync    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 公平锁</li><li>NonfairSync    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 非公平锁</li></ul><p><img src="/images/lock/ReetrantLock/sync1.jpg"></p><p><strong>公平锁和非公平锁:</strong></p><ul><li>公平锁:每个线程都能获取到锁,很少出现死等的情况,ReetrantLock中由一个FIFO队列实现</li><li>非公平锁: 锁存在优先级或者抢占调度,Sychronized就是一类典型的非公平锁</li></ul><p>默认非公平锁,线程抢锁直接对state进行CAS操作,不考虑是否有线程在队列中等待锁,抢到则服务,否则加入队列尾部<br><img src="/images/lock/ReetrantLock/unfair.png"></p><p>公平锁实现:</p><p><img src="/images/lock/ReetrantLock/fair.png"></p><p>多了一个队列检查环节,hasQueuedPredecessors(查看对列中是否有后继节点)</p><h3 id="AQS-AbstractQueuedSynchronizer-的概念"><a href="#AQS-AbstractQueuedSynchronizer-的概念" class="headerlink" title="AQS(AbstractQueuedSynchronizer)的概念"></a>AQS(AbstractQueuedSynchronizer)的概念</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能:"></a>功能:</h4><p>从功能上来说,AQS就是提供同步功能的一个解释类,提供2种不同的加锁方法, ReetrantLock和ReentrantReadWriteLock都依赖它</p><p>独占锁:在ReetrantLock中,只用到了它独占锁的方法<br>共享锁:ReentrantReadWriteLock实现</p><h4 id="大致模型"><a href="#大致模型" class="headerlink" title="大致模型:"></a>大致模型:</h4><p><img src="/images/lock/ReetrantLock/Aqs.png"></p><ul><li>AQS内部维护了一个State变量(volatile),用于实现锁的可重入性</li><li>exclusive…用于存储当前占用锁的线程</li><li>AQS中维护了一个FIFO的队列,我们把它叫做CLH队列,队列的每个节点就是一个线程的封装类,CLH有两个指针,head和tail,head指向队列头部,tail指向队列尾部<br><img src="/images/lock/ReetrantLock/CLH.png"><br>如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。</li></ul><h4 id="AQS源码及实例分析"><a href="#AQS源码及实例分析" class="headerlink" title="AQS源码及实例分析"></a>AQS源码及实例分析</h4><p><strong>加锁过程</strong></p><p>当有新的Thread进入时,如图例thread5将要进入锁竞争时<br>首先它会去用CAS操作去尝试获取锁,失败就进入CLH队列,抢到则进行下一步:<br>   if state == 0:<br>    如果为0则表明此时还没有线程抢到锁,＂我是第一个＂,所以此时将state+1,接着set exclusiveOwnerThread = thread5</p><p>  else:<br>    不为0时说明有其他线程在占用锁,检查是否为当前线程(exclusiveOwnerThread)如果是则重入锁。<br><strong>解锁过程</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p><strong>排它锁和共享锁:</strong><br>ReentrantLock默认排它锁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Lock是一个接口,其有很多种实现,Lock和sychronized关键词不同,Lock依赖aqs实现锁,没有应用到底层jvm等相关的技术,更适合应用层的扩展,实现方式很多,更方便更加灵活。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;ReetrantLock</summary>
      
    
    
    
    <category term="Java" scheme="https://yellowrifle.github.io/categories/Java/"/>
    
    <category term="Java Lock" scheme="https://yellowrifle.github.io/categories/Java/Java-Lock/"/>
    
    
    <category term="Lock" scheme="https://yellowrifle.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>Mqtt</title>
    <link href="https://yellowrifle.github.io/2019/07/13/android-mqtt/"/>
    <id>https://yellowrifle.github.io/2019/07/13/android-mqtt/</id>
    <published>2019-07-13T06:39:23.000Z</published>
    <updated>2019-11-10T07:32:42.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mqtt聊天室"><a href="#Mqtt聊天室" class="headerlink" title="Mqtt聊天室"></a>Mqtt聊天室</h1><h4 id="想法来源"><a href="#想法来源" class="headerlink" title="想法来源"></a>想法来源</h4><p><strong>一直都想做mqtt协议相关的通信，之前物联网本来想采用mqtt做硬件和服务器通信的，后面又采用的socket通信，所以android就做了一个mqtt协议下的聊天室</strong></p><h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a><font color=red>执行阶段</font></h4><p><strong><font face="宋体" size =3>常用（Instant Messaging）实现方式及协议的说明</font></strong><br><strong>socket实现：</strong><br>scocket即套接字通信，它不是一种协议，准确说它是一个Tcp/ip协议实现的接口或一个抽象层。<br>用它可以实现客户端与服务器端的长连接即可实现转发,基本上所有的网络协议都看得到socket的影子.<br>自己造轮子才是真正的大佬<br><img src="/images/mqtt/socketselector.png"><br><strong>Xmqq协议:</strong><br>一种基于标准通用标记语言的子集XML的协议<br>XMPP的优点是：协议成熟，强大，可扩展性强，并且有成熟的开源方案。<br>XMPP的缺点是：信息冗余量大（信息的格式是 XML），因而费流量，费电。<br><strong>Http轮询</strong><br>这个应该是早期web采用的方式，定时向服务器发送请求实现消息获取,同步的浪费资源。<br><strong>Websocket:</strong><br>基于h5的应用层协议,实现了http长连接状态,包含一套标准的 API,可以实现http轮训，ajax轮询等一系列功能，应该是手机端和web端常用的通讯协议。<br><strong>Mqtt协议</strong><br>它工作在 TCP/IP协议族上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的发布/订阅型消息协议，其实它更适合为硬件提供服务，这里用在android上主要是个人爱好，主要实现流程：<br><img src="/images/mqtt/mqtt.png"></p><p><strong>实现逻辑：</strong><br>例：客户端１发布主题”haha”到服务器,其他客户端只要选择订阅”haha”这条主题,就能够相互进行通讯，具体通信逻辑有很多种，详细见mqtt文档.</p><p><strong>讲一下我们项目的情况：</strong><br>服务器dashboard:<br><img src="/images/mqtt/topic.png"></p><hr><p><img src="/images/mqtt/subscriber.png"></p><p>ClientID123456和ClientID这两个用户共同订阅了mqtt这个主题,这两个设备就可以开始通信了</p><p><strong><font face="宋体" size=5>二、项目介绍</font></strong></p><h4 id="1-项目组成："><a href="#1-项目组成：" class="headerlink" title="1.项目组成："></a>1.项目组成：</h4><p><strong>planet:</strong><br>之前用了一个叫soul的app里面的星球元素非常好看，所以就仿照了一个,点击过后就会跳转到聊天室界面，讲一下我理解的实现逻辑。<br>整个星云图是一个自定义的module,每个星云由很多星球组成，详细可以见<br><a href="https://github.com/misakuo/3dTagCloudAndroid">https://github.com/misakuo/3dTagCloudAndroid</a><br><img src="/images/mqtt/soulplanet.jpg"></p><p><strong>聊天室:</strong><br><img src="/images/mqtt/chatroom.png"><br><strong>项目服务器端采用的是emqtt的一个框架，它支持mqtt,websocket,http等多种协议，还支持redis,mongodb等数据库接口，还有安全接口等.</strong><br>搭建步骤省略。</p><p><strong>布局:</strong><br>整体布局就是1个recycleView然后自定义adapter,接收消息和发送消息显示的界面不同，怎么做呢？<br>这里定义了一个Message的实体类,每个消息有与其对应的UserId,我们通过这个进行区分，发送消息时消息里带上自己的UserId,这样通过目前message中的UserId和自己的UserId是否一直来判断是否是他人发出的信息，对应的进行显示就好了。</p><p><strong>Mqtt内部的一些点：</strong><br>这个项目里的应用还比较浅显，只是进行了一些方法的重写和理解，可以直接说就是搬运。逻辑大致是这样：<br>首先通过MqttAsyncClient这里类拿到mqtt实体进行连接<br>定义一个listener接口，进行逻辑监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface MqttListener &#123;</span><br><span class="line">    void onConnected();&#x2F;&#x2F;连接成功</span><br><span class="line">    void onFail();&#x2F;&#x2F;连接失败</span><br><span class="line">    void onLost();&#x2F;&#x2F;丢失连接</span><br><span class="line">    void onReceive(String topic, String message);&#x2F;&#x2F;接收到消息</span><br><span class="line">    void onSendSucc();&#x2F;&#x2F;消息发送成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次加载app启动时，就调用subscribe，进行主题订阅，如果发现没有该主题，就进行主题发布<br><strong>项目地址:</strong> <a href="https://github.com/YellowRifle/Mqtt-Instant-message-android">https://github.com/YellowRifle/Mqtt-Instant-message-android</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mqtt聊天室&quot;&gt;&lt;a href=&quot;#Mqtt聊天室&quot; class=&quot;headerlink&quot; title=&quot;Mqtt聊天室&quot;&gt;&lt;/a&gt;Mqtt聊天室&lt;/h1&gt;&lt;h4 id=&quot;想法来源&quot;&gt;&lt;a href=&quot;#想法来源&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="项目" scheme="https://yellowrifle.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="android" scheme="https://yellowrifle.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Java IO相关操作(socket)</title>
    <link href="https://yellowrifle.github.io/2019/07/03/java/"/>
    <id>https://yellowrifle.github.io/2019/07/03/java/</id>
    <published>2019-07-03T02:24:16.000Z</published>
    <updated>2019-11-17T06:21:04.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>java中最频繁的IO操作就是对网络的的IO了，其本质也是对文件进行IO操作，java中网络通信基石就是socket,windows和unix中网络通讯首选socket,当然也有其他方式的,待探讨.</p><p><strong>关于socket</strong>:</p><p>我的理解既然socket是tcp协议实现的一种接口，工作在传输层，其后的应用层http,ftp,dns等也是基于tcp，本质上也是通过socket进行实现(各自是一种特殊的socket),再高级一点的协议和websocket,netty,emqtt,activemq等都需要用到socket(待补充)<br>Socket本质上还是文件，因为Linux上一切皆文件，就是io操作，这里先看一下unix下的5种网络io模型，对比java中的实现理解要清晰点.</p><p><font color=red>“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答(转)</font></p><p><strong>关于阻塞与非阻塞</strong></p><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p><strong>关于同步与异步:</strong></p><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p><p>而异步则是相反，<em>调用</em>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>典型的异步编程模型比如Node.js</p><p><strong>阻塞与非阻塞与是否同步异步无关</strong></p><p><strong>Unix的5种Io模型:</strong></p><ul><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO(SIGIO)</li><li>异步IO</li></ul><p><strong>一、同步阻塞IO（Blocking IO）:</strong></p><p>用户调用Io操作后,进入block状态,直到数据读取数据完成，才释放cpu，大多数操作都是同步阻塞的,看下图<br><img src="/images/socket/aaio.png"></p><p>《linux高级程序设计》中讲到</p><blockquote><p>一旦进程期望读取数据,就调用read/write函数，进程从调用这些函数开始，一直到返回这段时间都处在阻塞状态，当recv正常返回时，进程继续其他操作</p></blockquote><p><strong>二、同步非阻塞IO（Non-blocking IO）:</strong></p><p>非阻塞IO就是用户进程调用IO系统调用，如果被读取的数据没有准备好，则立即返回，与<strong>阻塞式io</strong>区别就是，当数据没准备好时，阻塞式就会阻塞当前进程直到数据读写完毕，非阻塞则是数据没准备好，那好我先返回，返回个错误值。<br><img src="/images/socket/notaaio.png"></p><p>这种方式最大的问题应该就是它需要反复地去轮询数据是否准备好，这将是一个极浪费 CPU资源的操作，但是在大量短连接请求的http服务器中，由于并发请求数很高，所以几乎每一次recvfrom调用都有数据拷贝，所以也不会十分浪费CPU资源。</p><p><strong>三、IO多路复用（IO Multiplexing）:</strong></p><p>IO多路即经典的Reactor设计模式，有时也称为异步阻塞IO，unix下由select()系统调用或poll()或epoll()来实现（下面会说道它们的区别），本质上是将访问数据是否就绪的函数与读取数据的函数分开。</p><p>《linux高级程序设计》中</p><blockquote><p>多路复用方式任然是以阻塞方式等待文件Io准备好，但其可以同时等待多个文件描述符，如果当前有一个或多个socket有状态变化,则从阻塞状态返回，转而处理该文件描述符Io操作</p></blockquote><p><img src="/images/socket/mutiio.png"></p><p>多路复用的高级之处在于:它能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p><p>IO 多路技术一般在下面这些情况中被使用：</p><p>1、当一个客户端需要同时处理多个文件描述符的输入输出操作的时候（一般来说是标准的输入输出和网络套接字)，I/O 多路复用技术将会有机会得到使用。</p><p>2、当程序需要同时进行多个套接字的操作的时候。</p><p>3、如果一个 TCP 服务器程序同时处理正在侦听网络连接的套接字和已经连接好的套接字。</p><p>4、如果一个服务器程序同时使用 TCP 和 UDP 协议。</p><p>5、如果一个服务器同时使用多种服务并且每种服务可能使用不同的协议（比如 inetd就是这样的）。</p><p><strong>四、信号驱动IO(SIGIO):</strong></p><p>内核提供一种异步数据处理方式，让内核在文件描述符就绪后产生SIGIO信号，通知用户数据或空间准备好，信号驱动式IO模型不需要轮询检查底层IO数据是否就绪，而是被动接收信号，然后再调用recvfrom执行IO操作。</p><p><strong>比起多路复用IO模型来说，信号驱动IO模型针对的是一个IO的完成过程， 而多路复用IO模型针对的是多个IO同时进行时候的场景</strong></p><p><img src="/images/socket/singnalio.png"></p><p><strong>五、异步IO:</strong></p><p>异步IO模型的工作机制是，将整个IO操作（包括等待数据就绪，复制数据到应用程序工作空间）全都交给操作系统完成，操作系统完成整个过程之后，再通知应用程序。</p><p>异步IO模型跟信号驱动IO模型很相似，但是区别是信号驱动模型是在数据就绪的时候通知应用程序，应用程序再调用系统函数recvfrom进行IO操作。</p><p>而异步IO模型则是数据就绪且操作系统已经将数据拷贝进应用程序运行空间之后，操作系统再通知应用程序，这个过程中应用程序不需要阻塞。异步IO可以如下图表示</p><p><img src="/images/socket/synchronizedio.png"></p><h2 id="Java中的BIO-NIO-AIO"><a href="#Java中的BIO-NIO-AIO" class="headerlink" title="Java中的BIO,NIO,AIO:"></a>Java中的BIO,NIO,AIO:</h2><p><strong>netty中比较从权威的说法</strong></p><p><img src="/images/socket/totolinfo.png"></p><p>BIO:b有两说，一为base，jdk中最早抽象出的io体系；一为block，jdk 1.0 中的io体系是阻塞的。所以两说皆有道理，一般我们认为b取block之意 。</p><p>NIO:n也有两说，一为new，针对base而言；一为non-block，针对block而言 jdk1.4后推出,传统io是面向字节流的，而nio是面向缓冲区的。 </p><p>AIO:异步IO也有NI0.2之说。</p><p><strong>BIO(同步阻塞)通信模型图:</strong><br><img src="/images/socket/biomodel.png"><br>每建立一个Socket连接时，同时创建一个新线程对该Socket进行单独通信（采用阻塞的方式通信）。这种方式具有很高的响应速度，并且控制起来也很简单，在连接数较少的时候非常有效，但是如果对每一个连接都产生一个线程的无疑是对系统资源的一种浪费，如果连接数较多将会出现资源不足的情况。</p><p><strong>项目实例:我这里放github里面了自己down下来理解</strong></p><p><strong>伪异步IO模型:</strong></p><p>  为了改进这种一连接一线程的模型，我们可以使用线程池来管理这些线程，就相当于加了个缓冲区,实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型“。</p><p><img src="/images/socket/fakeAsy.png"></p><p>其实并没有解决前面提到的资源等待问题，依旧会等待Io操作完毕.<br>下面祭出心心念念的NIO</p><p><strong>NIO 模型:</strong><br>JavaNIO中引入了几个概念,chanel,buffer,selector<br><font color=red>传统的Io是面向字节流的，NIO是面向缓冲区的(即buffer)</font></p><p><strong>Buffer:</strong><br>Java NIO中的Buffer用于和NIO通道进行交互,缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。<br><strong>Chanel:</strong><br><img src="/images/socket/chanel.png"></p><p>Java NIO的通道类似流，但又有些不同：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的(InputStream,OutputStream分开的)。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>如上图所示，从通道读取数据到缓冲区，从缓冲区写入数据到通道。</p><p><strong>Selector:</strong></p><p>JavaNIO编程的基础是Selector，也就是多路复用，Selector会不断的轮询注册在Selector上的Channel，如果某个Channel上面发生读或写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取已经准备就绪的Channel集合，进行后续的I/O操作。</p><blockquote><p>jdk用epoll()取代了之前的selector,所以他并没有最大连接句柄的限制。也就是说，一个线程可以负责处理成千上万的客户端</p></blockquote><p>在NIO类库中加入Buffer对象，体现了新库与原IO的一个重要的区别。在面向流的IO中，可以将数据直接写入或读取到Stream对象中。在NIO库中，所有数据都是用缓冲区处理的（读写）。</p><p><img src="/images/socket/niomodel.png"></p><p><strong>AIO 模型:</strong></p><p>AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。<br>但是对AIO来说，则更加进了一步，它不是在IO准备好时再通知线程，而是在IO操作已经完成后，再给线程发出通知。因此AIO是不会阻塞的，此时我们的业务逻辑将变成一个回调函数，等待IO操作完成后，由系统自动触发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;headerlink&quot; title=&quot;概念：&quot;&gt;&lt;/a&gt;概念：&lt;/h2&gt;&lt;p&gt;java中最频繁的IO操作就是对网络的的IO了，其本质也是对文件进行IO操作，java中网络通信基石就是socket,windows</summary>
      
    
    
    
    <category term="Java" scheme="https://yellowrifle.github.io/categories/Java/"/>
    
    <category term="Java Basic" scheme="https://yellowrifle.github.io/categories/Java/Java-Basic/"/>
    
    
    <category term="NIO" scheme="https://yellowrifle.github.io/tags/NIO/"/>
    
  </entry>
  
</feed>
